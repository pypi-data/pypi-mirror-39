

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2. Matched-filter detection &mdash; EQcorrscan 0.3.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/EQcorrscan_logo.ico"/>
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="EQcorrscan 0.3.0 documentation" href="../index.html"/>
        <link rel="up" title="EQcorrscan tutorials" href="../tutorial.html"/>
        <link rel="next" title="3. Subspace Detection" href="subspace.html"/>
        <link rel="prev" title="1. Template creation" href="template-creation.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> EQcorrscan
          

          
            
            <img src="../_static/EQcorrscan_logo.jpg" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">1. Introduction to the EQcorrscan package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">2. EQcorrscan installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../updates.html">3. What’s new</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../tutorial.html">EQcorrscan tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="template-creation.html">1. Template creation</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2. Matched-filter detection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#match-filter-objects">2.1. Match-filter objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#template-creation">2.2. Template creation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tribe-creation">2.3. Tribe creation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matched-filter-detection-using-a-tribe">2.4. Matched-filter detection using a Tribe</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generating-a-party-from-a-detection-csv">2.5. Generating a Party from a Detection csv</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lag-calc-using-a-party">2.6. Lag-calc using a Party</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simple-example-match-filter-match-filter">2.7. Simple example - match-filter.match-filter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-limitations-and-what-to-do-about-it">2.8. Memory limitations and what to do about it</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-three-threshold-parameters">2.9. The three threshold parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#advanced-example-match-filter-match-filter">2.10. Advanced example - match-filter-match-filter</a></li>
<li class="toctree-l3"><a class="reference internal" href="#slurm-example">2.11. SLURM example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="subspace.html">3. Subspace Detection</a></li>
<li class="toctree-l2"><a class="reference internal" href="lag-calc.html">4. Lag-time and pick correction</a></li>
<li class="toctree-l2"><a class="reference internal" href="mag-calc.html">5. Magnitude calculation</a></li>
<li class="toctree-l2"><a class="reference internal" href="clustering.html">6. Clustering and stacking</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../core.html">4. Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">5. Utils</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">EQcorrscan</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../tutorial.html">EQcorrscan tutorials</a> &raquo;</li>
        
      <li>2. Matched-filter detection</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/tutorials/matched-filter.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="matched-filter-detection">
<h1>2. Matched-filter detection<a class="headerlink" href="#matched-filter-detection" title="Permalink to this headline">¶</a></h1>
<p>This tutorial will cover using both the match-filter objects, and using the
internal functions within match-filter.  The match-filter objects are designed
to simplify meta-data handling allowing for shorter code with fewer mistakes and
therefore more consistent results.</p>
<div class="section" id="match-filter-objects">
<h2>2.1. Match-filter objects<a class="headerlink" href="#match-filter-objects" title="Permalink to this headline">¶</a></h2>
<p>The match-filter module contains five objects:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="../submodules/core.match_filter.Tribe.html"><span class="doc">Tribe</span></a></li>
<li><a class="reference internal" href="../submodules/core.match_filter.Template.html"><span class="doc">Template</span></a></li>
<li><a class="reference internal" href="../submodules/core.match_filter.Party.html"><span class="doc">Party</span></a></li>
<li><a class="reference internal" href="../submodules/core.match_filter.Family.html"><span class="doc">Family</span></a></li>
<li><a class="reference internal" href="../submodules/core.match_filter.Detection.html"><span class="doc">Detection</span></a></li>
</ul>
</div></blockquote>
<p>The <a class="reference internal" href="../submodules/core.match_filter.Tribe.html"><span class="doc">Tribe</span></a> object is a container for
multiple <a class="reference internal" href="../submodules/core.match_filter.Template.html"><span class="doc">Template</span></a> objects.
<a class="reference internal" href="../submodules/core.match_filter.Template.html"><span class="doc">Templates</span></a> contain the waveforms
of the template alongside the metadata used to generate the template.  Both
<a class="reference internal" href="../submodules/core.match_filter.Template.html"><span class="doc">Templates</span></a> and
<a class="reference internal" href="../submodules/core.match_filter.Tribe.html"><span class="doc">Tribes</span></a> can be written to disk as
tar archives containing the waveform data in miniseed format, event catalogues
associated with the <a class="reference internal" href="../submodules/core.match_filter.Template.html"><span class="doc">Templates</span></a>
(if provided) in quakeml format and meta-data in a csv file.  This archives
can be read back in or transferred between machines.</p>
<p>The <a class="reference internal" href="../submodules/core.match_filter.Detection.html"><span class="doc">Detection</span></a>,
<a class="reference internal" href="../submodules/core.match_filter.Family.html"><span class="doc">Family</span></a> and
<a class="reference internal" href="../submodules/core.match_filter.Party.html"><span class="doc">Party</span></a> objects are heirachical,
a single <a class="reference internal" href="../submodules/core.match_filter.Detection.html"><span class="doc">Detection</span></a> object
describes a single event detection, and contains information regarding how
the detection was made, what time it was made at alongside other useful
information, it does not store the
<a class="reference internal" href="../submodules/core.match_filter.Template.html"><span class="doc">Template</span></a> object used for the
detection, but does store a reference to the name of the
<a class="reference internal" href="../submodules/core.match_filter.Template.html"><span class="doc">Template</span></a>.
<a class="reference internal" href="../submodules/core.match_filter.Family.html"><span class="doc">Family</span></a> objects are containers
for multiple <a class="reference internal" href="../submodules/core.match_filter.Detection.html"><span class="doc">Detections</span></a> made
using a single <a class="reference internal" href="../submodules/core.match_filter.Template.html"><span class="doc">Template</span></a>
(name chosen to match the literature).  These objects do contain the
<a class="reference internal" href="../submodules/core.match_filter.Template.html"><span class="doc">Template</span></a> used for the detections,
and as such can be used to re-create the list of detections is necessary.
<a class="reference internal" href="../submodules/core.match_filter.Party.html"><span class="doc">Party</span></a> objects are containers for
multiple <a class="reference internal" href="../submodules/core.match_filter.Family.html"><span class="doc">Family</span></a> objects.  All
objects in the detection heirachy have read and write methods - we recommend
writing to tar archives (default) for Party and Family objects, as this will
store all metadata used in detection, which should allow for straightforward
reproduction of results.</p>
</div>
<div class="section" id="template-creation">
<h2>2.2. Template creation<a class="headerlink" href="#template-creation" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="../submodules/core.match_filter.Template.html"><span class="doc">Templates</span></a> have a construct
method which accesses the functions in
<a class="reference internal" href="../submodules/core.template_gen.html"><span class="doc">template_gen</span></a>.  Template.construct
only has access to methods that work on individual events, and not catalogs; for
that use the Tribe.construct method. For example, we can use the <em>from_sac</em>
method to make a Template from a series of SAC files associated with a single
event:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">glob</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">eqcorrscan.core.match_filter</span> <span class="kn">import</span> <span class="n">Template</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sac_files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;eqcorrscan/tests/test_data/SAC/2014p611252/*&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sac_files is now a list of all the SAC files for event id:2014p611252</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span> <span class="o">=</span> <span class="n">Template</span><span class="p">()</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">method</span><span class="o">=</span><span class="s1">&#39;from_sac&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;test&#39;</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">highcut</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
<span class="gp">... </span>     <span class="n">samp_rate</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">filt_order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">prepick</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">swin</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
<span class="gp">... </span>     <span class="n">length</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">sac_files</span><span class="o">=</span><span class="n">sac_files</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="tribe-creation">
<h2>2.3. Tribe creation<a class="headerlink" href="#tribe-creation" title="Permalink to this headline">¶</a></h2>
<p>As eluded to above, Template.construct only works for individual events, to
make a lot of templates we have to use the Tribe.construct method. The syntax
is similar, but we don’t specify names - templates are named according
to their start-time, but you can rename them later if you wish:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">eqcorrscan.core.match_filter</span> <span class="kn">import</span> <span class="n">Tribe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">obspy.clients.fdsn</span> <span class="kn">import</span> <span class="n">Client</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s1">&#39;NCEDC&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">catalog</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_events</span><span class="p">(</span><span class="n">eventid</span><span class="o">=</span><span class="s1">&#39;72572665&#39;</span><span class="p">,</span> <span class="n">includearrivals</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># To speed the example we have a catalog of one event, but you can have</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># more, we are also only using the first five picks, again to speed the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># example.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">catalog</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">catalog</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">picks</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tribe</span> <span class="o">=</span> <span class="n">Tribe</span><span class="p">()</span><span class="o">.</span><span class="n">construct</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">method</span><span class="o">=</span><span class="s1">&#39;from_client&#39;</span><span class="p">,</span> <span class="n">catalog</span><span class="o">=</span><span class="n">catalog</span><span class="p">,</span> <span class="n">client_id</span><span class="o">=</span><span class="s1">&#39;NCEDC&#39;</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
<span class="gp">... </span>     <span class="n">highcut</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>  <span class="n">samp_rate</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">filt_order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="mf">6.0</span><span class="p">,</span> <span class="n">prepick</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
<span class="gp">... </span>     <span class="n">swin</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">process_len</span><span class="o">=</span><span class="mi">3600</span><span class="p">,</span> <span class="n">all_horiz</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="matched-filter-detection-using-a-tribe">
<h2>2.4. Matched-filter detection using a Tribe<a class="headerlink" href="#matched-filter-detection-using-a-tribe" title="Permalink to this headline">¶</a></h2>
<p>Both Tribe and Template objects have <em>detect</em> methods.  These methods call
the main match_filter function.  They can be given an un-processed stream and
will complete the appropriate processing using the same processing values stored
in the Template objects.  Because Tribe objects can contain Templates with a
range of processing values, this work is completed in groups for groups of
Templates with the same processing values.  The Tribe object also has a
client_detect method which will download the appropriate data.  Both <em>detect</em>
and <em>client_detect</em> methods return Party objects.</p>
<p>For example, we can use the Tribe we created above to detect through a day of
data by running the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">UTCDateTime</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">party</span><span class="p">,</span> <span class="n">stream</span> <span class="o">=</span> <span class="n">tribe</span><span class="o">.</span><span class="n">client_detect</span><span class="p">(</span>
<span class="gp">... </span>     <span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
<span class="gp">... </span>     <span class="n">endtime</span><span class="o">=</span><span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">threshold_type</span><span class="o">=</span><span class="s1">&#39;MAD&#39;</span><span class="p">,</span>
<span class="gp">... </span>     <span class="n">trig_int</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">plotvar</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">return_stream</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="generating-a-party-from-a-detection-csv">
<h2>2.5. Generating a Party from a Detection csv<a class="headerlink" href="#generating-a-party-from-a-detection-csv" title="Permalink to this headline">¶</a></h2>
<p>If you are moving from detections written out as a csv file from an older
version of EQcorrscan, but want to use Party objects now, then this section is
for you!</p>
<p>First, you need to generate a Tribe from the templates you used to make the
detections.  Instructions for this are in the
<a class="reference internal" href="template-creation.html"><span class="doc">Template creation tutorial</span></a>
section.</p>
<p>Once you have a Tribe, you can generate a Party using the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">detections</span> <span class="o">=</span> <span class="n">read_detections</span><span class="p">(</span><span class="n">detection_file</span><span class="p">)</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">party</span> <span class="o">=</span> <span class="n">Party</span><span class="p">()</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">tribe</span><span class="p">:</span> 
<span class="gp">... </span>   <span class="n">template_detections</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">detections</span>
<span class="gp">... </span>                          <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">template_name</span> <span class="o">==</span> <span class="n">template</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
<span class="gp">... </span>   <span class="n">family</span> <span class="o">=</span> <span class="n">Family</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="n">template</span><span class="p">,</span> <span class="n">detections</span><span class="o">=</span><span class="n">template_detections</span><span class="p">)</span>
<span class="gp">... </span>   <span class="n">party</span> <span class="o">+=</span> <span class="n">family</span>
</pre></div>
</div>
</div>
<div class="section" id="lag-calc-using-a-party">
<h2>2.6. Lag-calc using a Party<a class="headerlink" href="#lag-calc-using-a-party" title="Permalink to this headline">¶</a></h2>
<p>Because parties contain Detection and Template information they can be used to
generate re-picked catalogues using lag-calc:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">merge</span><span class="p">()</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="s1">&#39;station&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repicked_catalog</span> <span class="o">=</span> <span class="n">party</span><span class="o">.</span><span class="n">lag_calc</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">pre_processed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">shift_len</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">min_cc</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span> 
<span class="go">5 Trace(s) in Stream:...</span>
</pre></div>
</div>
<p>By using the above examples you can go from a standard catalog available from
data centers, to a matched-filter detected and cross-correlation repicked
catalog in a handful of lines.</p>
</div>
<div class="section" id="simple-example-match-filter-match-filter">
<h2>2.7. Simple example - match-filter.match-filter<a class="headerlink" href="#simple-example-match-filter-match-filter" title="Permalink to this headline">¶</a></h2>
<p>This example does not work out of the box, you will have to have your own templates
and data, and set things up for this.  However, in principle matched-filtering
can be as simple as:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">eqcorrscan.core</span> <span class="kn">import</span> <span class="n">match_filter</span>
<span class="kn">from</span> <span class="nn">eqcorrscan.utils</span> <span class="kn">import</span> <span class="n">pre_processing</span>
<span class="kn">from</span> <span class="nn">obspy</span> <span class="kn">import</span> <span class="n">read</span>

<span class="c1"># Read in and process the daylong data</span>
<span class="n">st</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="s1">&#39;continuous_data&#39;</span><span class="p">)</span>
<span class="c1"># Use the same filtering and sampling parameters as your template!</span>
<span class="n">st</span> <span class="o">=</span> <span class="n">pre_processing</span><span class="o">.</span><span class="n">dayproc</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">highcut</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">filt_order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                            <span class="n">samp_rate</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                            <span class="n">starttime</span><span class="o">=</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span><span class="o">.</span><span class="n">date</span><span class="p">)</span>
<span class="c1"># Read in the templates</span>
<span class="n">templates</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">template_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;template_1&#39;</span><span class="p">,</span> <span class="s1">&#39;template_2&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">template_file</span> <span class="ow">in</span> <span class="n">template_names</span><span class="p">:</span>
     <span class="n">templates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">template_file</span><span class="p">))</span>
<span class="n">detections</span> <span class="o">=</span> <span class="n">match_filter</span><span class="o">.</span><span class="n">match_filter</span><span class="p">(</span>
     <span class="n">template_names</span><span class="o">=</span><span class="n">template_names</span><span class="p">,</span> <span class="n">template_list</span><span class="o">=</span><span class="n">templates</span><span class="p">,</span> <span class="n">st</span><span class="o">=</span><span class="n">st</span><span class="p">,</span>
     <span class="n">threshold</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">threshold_type</span><span class="o">=</span><span class="s1">&#39;MAD&#39;</span><span class="p">,</span> <span class="n">trig_int</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">plotvar</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>This will create a list of detections, which are of class detection.  You can
write out the detections to a csv (colon separated) using the detection.write
method, set <cite>append=True</cite> to write all the detections to one file.  Beware though,
if this is set and the file already exists, it will just add on to the old file.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">detection</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">:</span>
     <span class="n">detection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;my_first_detections.csv&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-limitations-and-what-to-do-about-it">
<h2>2.8. Memory limitations and what to do about it<a class="headerlink" href="#memory-limitations-and-what-to-do-about-it" title="Permalink to this headline">¶</a></h2>
<p>You may (if you are running large numbers of templates, long data durations, or using
a machine with small memory) run in to errors to do with memory consumption. The
most obvious symptom of this is your computer freezing because it has allocated
all of its RAM, or declaring that it cannot allocate memory.  Because EQcorrscan
computes correlations in parallel for multiple templates for the same data period,
it will generate a large number of correlation vectors.  At start-up, EQcorrscan
will try to assign the memory it needs (although it then requires a little more
later to do the summation across channels), so you might find that it fills your
memory very early - this is just to increase efficiency and ensure that the memory
is available when needed.</p>
<p>To get around memory limitations you can:</p>
<ul class="simple">
<li>Reduce the number of templates you run in parallel at once - for example you can
make groups of a number of templates and run that group in parallel, before running
the next group in parallel.  This is not much less efficient, unless you have
a machine with more CPU cores than your group-size.</li>
<li>Reduce the length of data you are correlating at any one time.  The default is
to use day-long files, but there is nothing stopping you using shorter waveform
durations.</li>
<li>Reduce the number of channels in templates to only those that you need.  Note,
EQcorrscan will generate vectors of zeros for templates that are missing a
channel that is present in other templates, again for processing efficiency,
if not memory efficiency.</li>
<li>Reduce your sampling rate.  Obviously this needs to be at-least twice as large
as your upper frequency filter, but much above this is wasted data.</li>
</ul>
<p>As an example of this: we run 100, 5-channel templates sampled at 20 Hz through
day-long data on a 128GB RAM machine without issue, however, running 200 templates
is too much memory.</p>
</div>
<div class="section" id="the-three-threshold-parameters">
<h2>2.9. The three threshold parameters<a class="headerlink" href="#the-three-threshold-parameters" title="Permalink to this headline">¶</a></h2>
<p>The match-filter routine has three key threshold parameters:</p>
<ul class="simple">
<li><strong>threshold_type</strong> can either be MAD, abs or av_chan_corr.  MAD stands for Median Absolute
Deviation and is the most commonly used detection statistic in matched-filter studies.
abs is the absolute cross-channel correlation sum, note that if you have different
numbers of channels in your templates then this threshold metric probably isn’t for you.
av_chan_corr sets a threshold in the cross-channel correlation sum based on av_chan_corr x number of channels.</li>
<li><strong>threshold</strong> is the value used for the above metric.</li>
<li><strong>trig_int</strong> is the minimum interval in seconds for a detection using the same template.
If there are multiple detections within this window for a single template then EQcorrscan
will only give the best one (that exceeds the threshold the most).</li>
</ul>
</div>
<div class="section" id="advanced-example-match-filter-match-filter">
<h2>2.10. Advanced example - match-filter-match-filter<a class="headerlink" href="#advanced-example-match-filter-match-filter" title="Permalink to this headline">¶</a></h2>
<p>In this section we will outline using the templates generated in the first tutorial
to scan for similar earthquakes within a day of data.  This small example does not truly exploit the parallel
operations within this package however, so you would be encouraged to think
about where parallel operations occur (<em>hint, the code can run one template
per CPU</em>), and why there are –instance and–splits flags in the other
scripts in the github repository (<em>hint, if you have heaps of memory
and CPUs you can do some brute force day parallelisation!</em>).</p>
<p>The main processing flow is outlined in the figure below, note the main speedups
in this process are achieved by running multiple templates at once, however this
increases memory usage.  If memory is a problem there are flags (mem_issue) in the
match_filter.py source that can be turned on - the codes will then write temporary
files, which is slower, but can allow for more data crunching at once, your trade-off,
your call.</p>
<a class="reference internal image-reference" href="../_images/processing_flow.png"><img alt="processing_flow.png" class="align-center" src="../_images/processing_flow.png" style="width: 600px;" /></a>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Simple tutorial to demonstrate some of the basic capabilities of the EQcorrscan</span>
<span class="sd">matched-filter detection routine.  This builds on the template generation</span>
<span class="sd">tutorial and uses those templates.  If you haven&#39;t run that tutorial script</span>
<span class="sd">then you will need to before you can run this script.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">glob</span>

<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">cpu_count</span>
<span class="kn">from</span> <span class="nn">obspy.clients.fdsn</span> <span class="k">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">obspy</span> <span class="k">import</span> <span class="n">UTCDateTime</span><span class="p">,</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">read</span>

<span class="kn">from</span> <span class="nn">eqcorrscan.utils</span> <span class="k">import</span> <span class="n">pre_processing</span>
<span class="kn">from</span> <span class="nn">eqcorrscan.utils</span> <span class="k">import</span> <span class="n">plotting</span>
<span class="kn">from</span> <span class="nn">eqcorrscan.core</span> <span class="k">import</span> <span class="n">match_filter</span>


<span class="k">def</span> <span class="nf">run_tutorial</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">process_len</span><span class="o">=</span><span class="mi">3600</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main function to run the tutorial dataset.&quot;&quot;&quot;</span>
    <span class="c1"># First we want to load our templates</span>
    <span class="n">template_names</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;tutorial_template_*.ms&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">template_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Template files not found, have you run the template &#39;</span> <span class="o">+</span>
                      <span class="s1">&#39;creation tutorial?&#39;</span><span class="p">)</span>

    <span class="n">templates</span> <span class="o">=</span> <span class="p">[</span><span class="n">read</span><span class="p">(</span><span class="n">template_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">template_name</span> <span class="ow">in</span> <span class="n">template_names</span><span class="p">]</span>

    <span class="c1"># Work out what stations we have and get the data for them</span>
    <span class="n">stations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">template</span> <span class="ow">in</span> <span class="n">templates</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">template</span><span class="p">:</span>
            <span class="n">stations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">station</span><span class="p">,</span> <span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">channel</span><span class="p">))</span>
    <span class="c1"># Get a unique list of stations</span>
    <span class="n">stations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">stations</span><span class="p">))</span>

    <span class="c1"># We will loop through the data chunks at a time, these chunks can be any</span>
    <span class="c1"># size, in general we have used 1 day as our standard, but this can be</span>
    <span class="c1"># as short as five minutes (for MAD thresholds) or shorter for other</span>
    <span class="c1"># threshold metrics. However the chunk size should be the same as your</span>
    <span class="c1"># template process_len.</span>

    <span class="c1"># You should test different parameters!!!</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">UTCDateTime</span><span class="p">(</span><span class="mi">2016</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chunk_start</span> <span class="o">=</span> <span class="n">start_time</span>
    <span class="k">while</span> <span class="n">chunk_start</span> <span class="o">&lt;</span> <span class="n">end_time</span><span class="p">:</span>
        <span class="n">chunk_end</span> <span class="o">=</span> <span class="n">chunk_start</span> <span class="o">+</span> <span class="n">process_len</span>
        <span class="k">if</span> <span class="n">chunk_end</span> <span class="o">&gt;</span> <span class="n">end_time</span><span class="p">:</span>
            <span class="n">chunk_end</span> <span class="o">=</span> <span class="n">end_time</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">chunk_start</span><span class="p">,</span> <span class="n">chunk_end</span><span class="p">))</span>
        <span class="n">chunk_start</span> <span class="o">+=</span> <span class="n">process_len</span>

    <span class="n">unique_detections</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Set up a client to access the GeoNet database</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="s2">&quot;GEONET&quot;</span><span class="p">)</span>

    <span class="c1"># Note that these chunks do not rely on each other, and could be paralleled</span>
    <span class="c1"># on multiple nodes of a distributed cluster, see the SLURM tutorial for</span>
    <span class="c1"># an example of this.</span>
    <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="c1"># Generate the bulk information to query the GeoNet database</span>
        <span class="n">bulk_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">station</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">:</span>
            <span class="n">bulk_info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;NZ&#39;</span><span class="p">,</span> <span class="n">station</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span>
                              <span class="n">station</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;H&#39;</span> <span class="o">+</span> <span class="n">station</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">))</span>

        <span class="c1"># Note this will take a little while.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Downloading seismic data, this may take a while&#39;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">get_waveforms_bulk</span><span class="p">(</span><span class="n">bulk_info</span><span class="p">)</span>
        <span class="c1"># Merge the stream, it will be downloaded in chunks</span>
        <span class="n">st</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;interpolate&#39;</span><span class="p">)</span>

        <span class="c1"># Set how many cores we want to parallel across, we will set this</span>
        <span class="c1"># to four as this is the number of templates, if your machine has</span>
        <span class="c1"># fewer than four cores/CPUs the multiprocessing will wait until there</span>
        <span class="c1"># is a free core.</span>
        <span class="c1"># Setting this to be higher than the number of templates will have no</span>
        <span class="c1"># increase in speed as only detections for each template are computed</span>
        <span class="c1"># in parallel.  It may also slow your processing by using more memory</span>
        <span class="c1"># than needed, to the extent that swap may be filled.</span>
        <span class="k">if</span> <span class="n">cpu_count</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">templates</span><span class="p">):</span>
            <span class="n">ncores</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ncores</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">templates</span><span class="p">)</span>

        <span class="c1"># Pre-process the data to set frequency band and sampling rate</span>
        <span class="c1"># Note that this is, and MUST BE the same as the parameters used for</span>
        <span class="c1"># the template creation.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Processing the seismic data&#39;</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">pre_processing</span><span class="o">.</span><span class="n">shortproc</span><span class="p">(</span>
            <span class="n">st</span><span class="p">,</span> <span class="n">lowcut</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">highcut</span><span class="o">=</span><span class="mf">9.0</span><span class="p">,</span> <span class="n">filt_order</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">samp_rate</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span>
            <span class="n">debug</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">num_cores</span><span class="o">=</span><span class="n">ncores</span><span class="p">,</span> <span class="n">starttime</span><span class="o">=</span><span class="n">t1</span><span class="p">,</span> <span class="n">endtime</span><span class="o">=</span><span class="n">t2</span><span class="p">)</span>
        <span class="c1"># Convert from list to stream</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">Stream</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>

        <span class="c1"># Now we can conduct the matched-filter detection</span>
        <span class="n">detections</span> <span class="o">=</span> <span class="n">match_filter</span><span class="o">.</span><span class="n">match_filter</span><span class="p">(</span>
            <span class="n">template_names</span><span class="o">=</span><span class="n">template_names</span><span class="p">,</span> <span class="n">template_list</span><span class="o">=</span><span class="n">templates</span><span class="p">,</span>
            <span class="n">st</span><span class="o">=</span><span class="n">st</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span> <span class="n">threshold_type</span><span class="o">=</span><span class="s1">&#39;MAD&#39;</span><span class="p">,</span> <span class="n">trig_int</span><span class="o">=</span><span class="mf">6.0</span><span class="p">,</span>
            <span class="n">plotvar</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">plotdir</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="n">ncores</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">plot_format</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">)</span>

        <span class="c1"># Now lets try and work out how many unique events we have just to</span>
        <span class="c1"># compare with the GeoNet catalog of 20 events on this day in this</span>
        <span class="c1"># sequence</span>
        <span class="k">for</span> <span class="n">master</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">slave</span> <span class="ow">in</span> <span class="n">detections</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">master</span> <span class="o">==</span> <span class="n">slave</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">master</span><span class="o">.</span><span class="n">detect_time</span> <span class="o">-</span>
                                               <span class="n">slave</span><span class="o">.</span><span class="n">detect_time</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">:</span>
                    <span class="c1"># If the events are within 1s of each other then test which</span>
                    <span class="c1"># was the &#39;best&#39; match, strongest detection</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">master</span><span class="o">.</span><span class="n">detect_val</span> <span class="o">&gt;</span> <span class="n">slave</span><span class="o">.</span><span class="n">detect_val</span><span class="p">:</span>
                        <span class="n">keep</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Removed detection at </span><span class="si">%s</span><span class="s1"> with cccsum </span><span class="si">%s</span><span class="s1">&#39;</span>
                              <span class="o">%</span> <span class="p">(</span><span class="n">master</span><span class="o">.</span><span class="n">detect_time</span><span class="p">,</span> <span class="n">master</span><span class="o">.</span><span class="n">detect_val</span><span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Keeping detection at </span><span class="si">%s</span><span class="s1"> with cccsum </span><span class="si">%s</span><span class="s1">&#39;</span>
                              <span class="o">%</span> <span class="p">(</span><span class="n">slave</span><span class="o">.</span><span class="n">detect_time</span><span class="p">,</span> <span class="n">slave</span><span class="o">.</span><span class="n">detect_val</span><span class="p">))</span>
                        <span class="k">break</span>
            <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                <span class="n">unique_detections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">master</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Detection at :&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">master</span><span class="o">.</span><span class="n">detect_time</span><span class="p">)</span> <span class="o">+</span>
                      <span class="s1">&#39; for template &#39;</span> <span class="o">+</span> <span class="n">master</span><span class="o">.</span><span class="n">template_name</span> <span class="o">+</span>
                      <span class="s1">&#39; with a cross-correlation sum of: &#39;</span> <span class="o">+</span>
                      <span class="nb">str</span><span class="p">(</span><span class="n">master</span><span class="o">.</span><span class="n">detect_val</span><span class="p">))</span>
                <span class="c1"># We can plot these too</span>
                <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
                    <span class="n">stplot</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">template</span> <span class="o">=</span> <span class="n">templates</span><span class="p">[</span><span class="n">template_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span>
                        <span class="n">master</span><span class="o">.</span><span class="n">template_name</span><span class="p">)]</span>
                    <span class="n">lags</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">tr</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">starttime</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">template</span><span class="p">])</span>
                    <span class="n">maxlag</span> <span class="o">=</span> <span class="n">lags</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">stplot</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">starttime</span><span class="o">=</span><span class="n">master</span><span class="o">.</span><span class="n">detect_time</span> <span class="o">-</span> <span class="mi">10</span><span class="p">,</span>
                                <span class="n">endtime</span><span class="o">=</span><span class="n">master</span><span class="o">.</span><span class="n">detect_time</span> <span class="o">+</span> <span class="n">maxlag</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span>
                    <span class="n">plotting</span><span class="o">.</span><span class="n">detection_multiplot</span><span class="p">(</span>
                        <span class="n">stplot</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="p">[</span><span class="n">master</span><span class="o">.</span><span class="n">detect_time</span><span class="o">.</span><span class="n">datetime</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;We made a total of &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_detections</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; detections&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unique_detections</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">run_tutorial</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="slurm-example">
<h2>2.11. SLURM example<a class="headerlink" href="#slurm-example" title="Permalink to this headline">¶</a></h2>
<p>When the authors of EQcorrscan work on large projects, we use grid computers with
the SLURM (Simple Linux Utility for Resource Management) job scheduler installed.
To facilitate ease of setup, what follows is an example of how we run this.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#SBATCH -J MatchTest</span>
<span class="c1">#SBATCH -A ##########</span>
<span class="c1">#SBATCH --time=12:00:00</span>
<span class="c1">#SBATCH --mem=7G</span>
<span class="c1">#SBATCH --nodes=1</span>
<span class="c1">#SBATCH --output=matchout_%a.txt</span>
<span class="c1">#SBATCH --error=matcherr_%a.txt</span>
<span class="c1">#SBATCH --cpus-per-task=16</span>
<span class="c1">#SBATCH --array=0-49</span>

<span class="c1"># Load the required modules here.</span>
module load OpenCV/2.4.9-intel-2015a
module load ObsPy/0.10.3rc1-intel-2015a-Python-2.7.9
module load joblib/0.8.4-intel-2015a-Python-2.7.9

<span class="c1"># Run your python script using srun</span>
srun python2.7 LFEsearch.py --splits <span class="m">50</span> --instance <span class="nv">$SLURM_ARRAY_TASK_ID</span>
</pre></div>
</div>
<p>Where we use a script (LFEsearch.py) that accepts splits and instance flags,
this section of the script is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Split</span><span class="o">=</span><span class="bp">False</span>
<span class="n">instance</span><span class="o">=</span><span class="bp">False</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">flag</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;--debug&#39;</span><span class="p">:</span>
        <span class="n">Test</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">Prep</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;--debug-prep&#39;</span><span class="p">:</span>
        <span class="n">Test</span><span class="o">=</span><span class="bp">False</span>
        <span class="n">Prep</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;I don&#39;t recognise the argument, I only know --debug and --debug-prep&quot;</span><span class="p">)</span>
<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
    <span class="c1"># Arguments to allow the code to be run in multiple instances</span>
    <span class="n">Split</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">Test</span><span class="o">=</span><span class="bp">False</span>
    <span class="n">Prep</span><span class="o">=</span><span class="bp">False</span>
    <span class="n">args</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;--instance&#39;</span><span class="p">:</span>
            <span class="n">instance</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">print</span> <span class="s1">&#39;I will run this for instance &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;--splits&#39;</span><span class="p">:</span>
            <span class="n">splits</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">print</span> <span class="s1">&#39;I will divide the days into &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">splits</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; chunks&#39;</span>

<span class="k">elif</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;I only take one argument, no arguments, or two flags with arguments&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">Test</span><span class="o">=</span><span class="bp">False</span>
    <span class="n">Prep</span><span class="o">=</span><span class="bp">False</span>
    <span class="n">Split</span><span class="o">=</span><span class="bp">False</span>
</pre></div>
</div>
<p>The full script is not included in EQcorrscan, but is available on request.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="subspace.html" class="btn btn-neutral float-right" title="3. Subspace Detection" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="template-creation.html" class="btn btn-neutral" title="1. Template creation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, 2016: EQcorrscan developers.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.3.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>