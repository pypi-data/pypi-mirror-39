"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var parser_js_1 = require("react-docgen-typescript/lib/parser.js");
var validateOptions_1 = __importDefault(require("./validateOptions"));
var generateDocgenCodeBlock_1 = __importDefault(require("./generateDocgenCodeBlock"));
function loader(source) {
    // Loaders can operate in either synchronous or asynchronous mode. Errors in
    // asynchronous mode should be reported using the supplied callback.
    // Will return a callback if operating in asynchronous mode.
    var callback = this.async();
    try {
        var newSource = processResource.call(this, source);
        if (!callback)
            return newSource;
        callback(null, newSource);
    }
    catch (e) {
        if (callback) {
            callback(e);
            return;
        }
        throw e;
    }
}
function processResource(source) {
    var _this = this;
    // Mark the loader as being cacheable since the result should be
    // deterministic.
    this.cacheable(true);
    var options = this.query || {};
    validateOptions_1.default(options);
    options.docgenCollectionName =
        options.docgenCollectionName || "STORYBOOK_REACT_CLASSES";
    if (typeof options.setDisplayName !== "boolean") {
        options.setDisplayName = true;
    }
    // Check resource against whitelists and blacklists.
    var includes = options.includes || ["\\.tsx$"];
    var excludes = options.excludes || ["node_modules"];
    var shouldProcess = includes.some(function (i) { return new RegExp(i).test(_this.resourcePath); });
    shouldProcess = shouldProcess
        ? !excludes.some(function (i) { return new RegExp(i).test(_this.resourcePath); })
        : false;
    if (!shouldProcess)
        return source;
    // Convert the loader's flat options into the expected structure for
    // react-docgen-typescript.
    // See: node_modules/react-docgen-typescript/lib/parser.d.ts
    var parserOptions = {
        propFilter: options.skipPropsWithName || options.skipPropsWithoutDoc
            ? {
                skipPropsWithName: options.skipPropsWithName || undefined,
                skipPropsWithoutDoc: options.skipPropsWithoutDoc || undefined,
            }
            : undefined,
    };
    // Configure parser using settings provided to loader.
    // See: node_modules/react-docgen-typescript/lib/parser.d.ts
    var parser = parser_js_1.withDefaultConfig(parserOptions);
    if (options.tsconfigPath) {
        parser = parser_js_1.withCustomConfig(options.tsconfigPath, parserOptions);
    }
    else if (options.compilerOptions) {
        parser = parser_js_1.withCompilerOptions(options.compilerOptions, parserOptions);
    }
    var componentDocs = parser.parse(this.resourcePath);
    // Return amended source code if there is docgen information available.
    if (componentDocs.length) {
        return generateDocgenCodeBlock_1.default({
            filename: this.resourcePath,
            source: source,
            componentDocs: componentDocs,
            docgenCollectionName: options.docgenCollectionName,
            setDisplayName: options.setDisplayName,
        });
    }
    // Return unchanged source code if no docgen information was available.
    return source;
}
exports.default = loader;
