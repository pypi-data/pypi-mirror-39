

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Scenario definition &mdash; mosaik 2.5.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="mosaik 2.5.1 documentation" href="index.html"/>
        <link rel="next" title="The simulator manager" href="simmanager.html"/>
        <link rel="prev" title="The high-level API" href="mosaik-api/high-level.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>
</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> mosaik
          

          
          </a>

          
            
            
              <div class="version">
                2.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="ecosystem/index.html">Modular Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="mosaik-api/index.html">The mosaik API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Scenario definition</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-setup">The setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#starting-simulators">Starting simulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instantiating-simulation-models">Instantiating simulation models</a></li>
<li class="toctree-l2"><a class="reference internal" href="#connecting-entities">Connecting entities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#running-the-simulation">Running the simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-achieve-bi-directional-data-flows">How to achieve bi-directional data-flows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-filter-entity-sets">How to filter entity sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-create-user-defined-connection-rules">How to create user-defined connection rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-retrieve-static-data-from-entities">How to retrieve static data from entities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-access-topology-and-data-flow-information">How to access topology and data-flow information</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-destroy-a-world">How to destroy a world</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-do-real-time-simulations">How to do real-time simulations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-call-extra-methods-of-a-simulator">How to call extra methods of a simulator</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="simmanager.html">The simulator manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="scheduler.html">Scheduling and simulation execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev/index.html">Developer&#8217;s Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="api_reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="about/index.html">About mosaik</a></li>
<li class="toctree-l1"><a class="reference internal" href="privacy.html">Privacy Policies</a></li>
<li class="toctree-l1"><a class="reference internal" href="legals.html">Legals</a></li>
<li class="toctree-l1"><a class="reference internal" href="datenschutz.html">Datenschutz</a></li>
<li class="toctree-l1"><a class="reference internal" href="impressum.html">Impressum</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">mosaik</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Scenario definition</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="_sources/scenario-definition.txt" rel="nofollow"> View page source</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="scenario-definition">
<h1>Scenario definition<a class="headerlink" href="#scenario-definition" title="Permalink to this headline">¶</a></h1>
<p>Modeling or composing a scenario in mosaik comprises three steps:</p>
<ol class="arabic simple">
<li>Starting simulators,</li>
<li>Instantiating models within the simulators, and</li>
<li>Connecting the model instances of different simulators to establish the data
flow between them.</li>
</ol>
<p>This page will show you how to create simple scenarios in these three steps.
It will also provide some recipes that allow you to create more complex
scenarios.</p>
<div class="section" id="the-setup">
<h2>The setup<a class="headerlink" href="#the-setup" title="Permalink to this headline">¶</a></h2>
<p>The central class for creating scenarios is <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World" title="mosaik.scenario.World"><code class="xref py py-class docutils literal"><span class="pre">mosaik.scenario.World</span></code></a> (for
your convenience, you can also import <code class="docutils literal"><span class="pre">World</span></code> directly from <code class="docutils literal"><span class="pre">mosaik</span></code>). This
class stores all data and state that belongs to your scenario and its
simulation. It also provides various methods that allow you to start simulators
and establish the data flows between them.</p>
<p>In this tutorial, we&#8217;ll create a very simple scenario using the example
simulation that is provided with the <a class="reference external" href="https://bitbucket.org/mosaik/mosaik-api-python/src">Python implementation of the simulator
API</a>.</p>
<p>We start by importing the <a class="reference internal" href="api_reference/mosaik.html#module-mosaik" title="mosaik"><code class="xref py py-mod docutils literal"><span class="pre">mosaik</span></code></a> package and creating
a <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World" title="mosaik.scenario.World"><code class="xref py py-class docutils literal"><span class="pre">World</span></code></a> instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mosaik</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim_config</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;ExampleSim&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="s1">&#39;example_sim.mosaik:ExampleSim&#39;</span><span class="p">},</span>
<span class="gp">... </span><span class="p">}</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">world</span> <span class="o">=</span> <span class="n">mosaik</span><span class="o">.</span><span class="n">World</span><span class="p">(</span><span class="n">sim_config</span><span class="p">)</span>
</pre></div>
</div>
<p>As we start simulator instances by using <em>world</em>, it needs to know what
simulators are available and how to start them. This is called the <em>sim config</em>
and is a dict that contains every simulator we want to use together with some
information on how to start it.</p>
<p>In our case, the only simulator is the <em>ExampleSim</em>. It will be started by importing
the module <code class="docutils literal"><span class="pre">example_sim.mosaik</span></code> and instantiating the class <code class="docutils literal"><span class="pre">ExampleSim</span></code>.
This is only possible with simulators written in Python 3. You can also let
mosaik start simulator as external processes or let it connect to already
running processes. The <a class="reference internal" href="simmanager.html"><span class="doc">simulator manager docs</span></a> explain how
this all works and give you some hints when to use which method of starting
a simulator.</p>
<p>In addition to the <em>sim config</em> you can optionally pass another dictionary to
<a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World" title="mosaik.scenario.World"><code class="xref py py-class docutils literal"><span class="pre">World</span></code></a> in order to overwrite some general parameters for mosaik (e.g.,
the host and port number for its network socket or timeouts).  Usually, the
defaults work just well.</p>
</div>
<div class="section" id="starting-simulators">
<h2>Starting simulators<a class="headerlink" href="#starting-simulators" title="Permalink to this headline">¶</a></h2>
<p>Now that the basic set-up is done, we can start our simulators:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exsim_0</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s1">&#39;ExampleSim&#39;</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Starting &quot;ExampleSim&quot; as &quot;ExampleSim-0&quot; ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exsim_1</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s1">&#39;ExampleSim&#39;</span><span class="p">)</span>
<span class="go">Starting &quot;ExampleSim&quot; as &quot;ExampleSim-1&quot; ...</span>
</pre></div>
</div>
<p>To start a simulator, we call <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.start" title="mosaik.scenario.World.start"><code class="xref py py-meth docutils literal"><span class="pre">World.start()</span></code></a> and pass the name of the
simulator. Mosaik looks up that name in its <em>sim config</em>, starts the simulator
for us and returns a <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.ModelFactory" title="mosaik.scenario.ModelFactory"><code class="xref py py-class docutils literal"><span class="pre">ModelFactory</span></code></a>. This factory allows us to
instantiate simulation models within that simulator.</p>
<p>In addition to the simulator name, you can pass further parameters for the
simulators. These parameters are passed to the simulator via the <a class="reference internal" href="mosaik-api/low-level.html#api-init"><span class="std std-ref">init()
API call</span></a>.</p>
</div>
<div class="section" id="instantiating-simulation-models">
<h2>Instantiating simulation models<a class="headerlink" href="#instantiating-simulation-models" title="Permalink to this headline">¶</a></h2>
<p>Simulators specify a set of public models in their meta data (see <a class="reference internal" href="mosaik-api/low-level.html#api-init"><span class="std std-ref">init()
API call</span></a>). These models can be accessed with the
<a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.ModelFactory" title="mosaik.scenario.ModelFactory"><code class="xref py py-class docutils literal"><span class="pre">ModelFactory</span></code></a> that <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.start" title="mosaik.scenario.World.start"><code class="xref py py-meth docutils literal"><span class="pre">World.start()</span></code></a> returns as if they were normal
Python classes. So to create one instance of <em>ExampleSim&#8217;s</em> model <em>A</em> we just
write:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">exsim_0</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">init_val</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This will create one instance of the <em>A</em> simulation model and pass the model
parameter <code class="docutils literal"><span class="pre">init_val=0</span></code> to it (see <a class="reference internal" href="mosaik-api/low-level.html#api-create"><span class="std std-ref">create() API call</span></a>).
Lets see what it is that gets returned to us:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">Entity(&#39;ExampleSim-0&#39;, &#39;0.0&#39;, &#39;ExampleSim&#39;, A)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sid</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">eid</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">full_id</span>
<span class="go">(&#39;ExampleSim-0&#39;, &#39;0.0&#39;, &#39;ExampleSim-0.0.0&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">sim_name</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">type</span>
<span class="go">(&#39;ExampleSim&#39;, &#39;A&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">children</span>
<span class="go">[]</span>
</pre></div>
</div>
<p>A model instances is represented in your scenario as an <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.Entity" title="mosaik.scenario.Entity"><code class="xref py py-class docutils literal"><span class="pre">Entity</span></code></a>. The
entity belongs to the simulator <em>ExampleSim-0</em>, has the ID <em>0.0</em> and its type
is <em>A</em>. The entity ID is unique within a simulator. To make it globally unique,
we prepend it with the simulator ID. This is called the entity&#8217;s <em>full ID</em> (see
<a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.Entity.full_id" title="mosaik.scenario.Entity.full_id"><code class="xref py py-attr docutils literal"><span class="pre">Entity.full_id</span></code></a>). You can also get a list of its child entities (which
is empty in this case).</p>
<p>In order to instantiate multiple instances of a model, you can either use
a simple list comprehension (or <code class="docutils literal"><span class="pre">for</span></code> loop) or call the static method
<cite>create()</cite> of the model:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">exsim_0</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">init_val</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b_set</span> <span class="o">=</span> <span class="n">exsim_1</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">init_val</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The list comprehension is more verbose but allows you to pass individual
parameter values to each instance. Using <code class="docutils literal"><span class="pre">create()</span></code> is more concise but all
three instance will have the same value for <em>init_val</em>. In both cases you&#8217;ll
get a list of entities (aka <a class="reference internal" href="glossary.html#term-entity-set"><span class="xref std std-term">entity sets</span></a>).</p>
</div>
<div class="section" id="connecting-entities">
<h2>Connecting entities<a class="headerlink" href="#connecting-entities" title="Permalink to this headline">¶</a></h2>
<p>If we would now run our simulation, both, <em>exsim_0</em> and <em>exsim_1</em> would run
in parallel and never exchange any data. To change that, we need to connect
the models providing input data to entities requiring this data. In our case,
we will connect the <em>val_out</em> attribute of the <em>A</em> instances with the <em>val_in</em>
attribute of the <em>B</em> instances:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a_set</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>  <span class="c1"># Put our first A instance to the others</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a_set</span><span class="p">,</span> <span class="n">b_set</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;val_out&#39;</span><span class="p">,</span> <span class="s1">&#39;val_in&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The method <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.connect" title="mosaik.scenario.World.connect"><code class="xref py py-meth docutils literal"><span class="pre">World.connect()</span></code></a> takes the source entity, the destination
entity and an arbitrary amount of <em>(source attribute, dest. attribute)</em> tuples.
If the name of the source attributes equals that of the destination attribute,
you can alternatively just pass a single string (e.g., <code class="docutils literal"><span class="pre">connect(a,</span> <span class="pre">b,</span>
<span class="pre">'attr')</span></code>).</p>
<p>You can only connect entities that belong to different simulators with each
other (that&#8217;s why we created two instances of the <em>ExampleSim</em>).</p>
<p>You are also not allowed to created circular dependencies (e.g., connect <em>a</em> to
<em>b</em> and then connect <em>b</em> to <em>a</em>). To allow a bidirectional exchange of data,
which is required for things like control strategies, there is another
mechanism that is explained in one of the next sections
(<a class="reference internal" href="#integrate-control-strategies"><span class="std std-ref">How to achieve bi-directional data-flows</span></a>).</p>
</div>
<div class="section" id="running-the-simulation">
<span id="id2"></span><h2>Running the simulation<a class="headerlink" href="#running-the-simulation" title="Permalink to this headline">¶</a></h2>
<p>When all simulators are started, models are instantiated and connected, we can
finally run our simulation:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  
<span class="go">Starting simulation.</span>
<span class="go">Simulation finished successfully.</span>
</pre></div>
</div>
<p>This will execute the simulation from time 0 until we reach the time <em>until</em>
(in simulated seconds). The <a class="reference internal" href="scheduler.html"><span class="doc">scheduler section</span></a> explains in
detail what happens when you call <code class="docutils literal"><span class="pre">run()</span></code>.</p>
<p>To wrap it all up, this is how our small example scenario finally looks like:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Setup</span>
<span class="kn">import</span> <span class="nn">mosaik</span>

<span class="n">sim_config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;ExampleSim&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="s1">&#39;example_sim.mosaik:ExampleSim&#39;</span><span class="p">},</span>
<span class="p">}</span>

<span class="n">world</span> <span class="o">=</span> <span class="n">mosaik</span><span class="o">.</span><span class="n">World</span><span class="p">(</span><span class="n">sim_config</span><span class="p">)</span>

<span class="c1"># Start simulators</span>
<span class="n">exsim_0</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s1">&#39;ExampleSim&#39;</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">exsim_1</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s1">&#39;ExampleSim&#39;</span><span class="p">)</span>

<span class="c1"># Instantiate models</span>
<span class="n">a_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">exsim_0</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">init_val</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="n">b_set</span> <span class="o">=</span> <span class="n">exsim_1</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">init_val</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Connect entities</span>
<span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a_set</span><span class="p">,</span> <span class="n">b_set</span><span class="p">):</span>
    <span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;val_out&#39;</span><span class="p">,</span> <span class="s1">&#39;val_in&#39;</span><span class="p">))</span>

<span class="c1"># Run simulation</span>
<span class="n">world</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="how-to-achieve-bi-directional-data-flows">
<span id="integrate-control-strategies"></span><h2>How to achieve bi-directional data-flows<a class="headerlink" href="#how-to-achieve-bi-directional-data-flows" title="Permalink to this headline">¶</a></h2>
<p>Bi-directional data-flows are important when you want to integrate, for
example, control strategies. However, this trivial approach is not allowed
in mosaik:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Send battery&#39;s active power value to the controller</span>
<span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">battery</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="c1"># Controller sends back a schedule to the battery</span>
<span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">battery</span><span class="p">,</span> <span class="s1">&#39;schedule&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The problem with this is that mosaik cannot know whether to compute <em>battery.P</em>
or <em>controller.schedule</em> first.</p>
<p>To solve this problem, you only connect the battery&#8217;s <em>P</em> to the controller and
let the control strategy set the new schedule via the asynchronous request
<a class="reference internal" href="mosaik-api/low-level.html#rpc-set-data"><span class="std std-ref">set_data</span></a>. To indicate this in your scenario, you set the
<em>async_request</em> flag of <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.connect" title="mosaik.scenario.World.connect"><code class="xref py py-meth docutils literal"><span class="pre">World.connect()</span></code></a> to <code class="docutils literal"><span class="pre">True</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">battery</span><span class="p">,</span> <span class="n">controller</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">async_requests</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>This way, mosaik will push the value for <em>P</em> from the battery to the
controller. It will then wait until the controller&#8217;s <a class="reference internal" href="mosaik-api/low-level.html#api-step"><span class="std std-ref">step</span></a> is
done before the next step for the battery will be computed.</p>
<p>The <em>step</em> implementation of the controller could roughly look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Conroller</span><span class="p">(</span><span class="n">Simulator</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
       <span class="n">schedule</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_schedule</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
       <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">mosaik</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">schedule</span><span class="p">)</span>
       <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span>
</pre></div>
</div>
</div>
<div class="section" id="how-to-filter-entity-sets">
<h2>How to filter entity sets<a class="headerlink" href="#how-to-filter-entity-sets" title="Permalink to this headline">¶</a></h2>
<p>When you create large-scale scenarios, you often work with large sets of
entities rather then single ones. This section provides some examples how you
can extract a sub-set of entities from a larger entity set based on arbitrary
criteria.</p>
<p>Lets assume that we have created a power grid with <a class="reference external" href="https://pypi.python.org/pypi/mosaik-pypower">mosaik-pypower</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">grid</span> <span class="o">=</span> <span class="n">pypower</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">gridfile</span><span class="o">=</span><span class="s1">&#39;data/grid.json&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">children</span>
</pre></div>
</div>
<p>Since mosaik-pypower&#8217;s <em>Grid</em> entity only serves as a container for the buses
and branches of our power grid, we directly bound its <em>children</em> to the name
<code class="docutils literal"><span class="pre">grid</span></code>. So <em>grid</em> is now a list containing a <em>RefBus</em> entity and multiple
<em>Transformer</em>, <em>PQBus</em> and <em>Branch</em> entities.</p>
<p>So how do we get a list of all transformers? This way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">transformers</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;Transformer&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>How do we get the single <em>RefBus</em>? This way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">refbus</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;RefBus&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Our <em>PQBus</em> entities are named like <em>Busbar_&lt;i&gt;</em> and <em>ConnectionPoint_&lt;i&gt;</em> to
indicate to which buses we can connect consumers and producers and to which we
shouldn&#8217;t connect anything. How do we get a list of all <em>ConnectionPoint</em>
buses? We might be tempted to do it this way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">conpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">eid</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ConnectionPoint_&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>The problem in this particular case is, that <em>mosaik-pypower</em> prepends a &#8220;grid
ID&#8221; to each entity ID, because it can handle multiple grid instances at once.
So our entity IDs are actually looking like this:
<em>&lt;grid_idx&gt;-ConnectionPoint_&lt;i&gt;</em>.  Using regular expressions, we can get our
list:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">regex_conpoint</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+-ConnectionPoint_\d+&#39;</span><span class="p">)</span>

<span class="n">conpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">regex_conpoint</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">eid</span><span class="p">)]</span>
</pre></div>
</div>
<p>If we want to connect certain consumers or producers to defined nodes in our
grid (e.g., your boss says: &#8220;This PV module needs to be connected to
<em>ConnectionPoint_23</em>!&#8221;), creating a dict instead of a list is a good idea:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">remove_grididx</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="o">.</span><span class="n">eid</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Little helper function</span>
<span class="n">cps_by_name</span> <span class="o">=</span> <span class="p">{</span><span class="n">remove_grididx</span><span class="p">(</span><span class="n">e</span><span class="p">):</span> <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">regex_conpoint</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">e</span><span class="p">)}</span>
</pre></div>
</div>
<p>This will create a mapping where the string <code class="docutils literal"><span class="pre">'ConnectionPoint_23'</span></code> maps to
the corresponding <code class="docutils literal"><span class="pre">Entity</span></code> instance.</p>
<p>This was just a small selection of how you can filter entity sets using
list/dict comprehensions. Alternatively, you can also use the <a class="reference external" href="http://docs.python.org/3/library/functions.html#filter" title="(in Python v3.7)"><code class="xref py py-func docutils literal"><span class="pre">filter()</span></code></a>
function or a normal <code class="docutils literal"><span class="pre">for</span></code> loop. You should also take at look at the
<a class="reference external" href="http://docs.python.org/3/library/itertools.html#module-itertools" title="(in Python v3.7)"><code class="xref py py-mod docutils literal"><span class="pre">itertools</span></code></a> and <a class="reference external" href="http://docs.python.org/3/library/functools.html#module-functools" title="(in Python v3.7)"><code class="xref py py-mod docutils literal"><span class="pre">functools</span></code></a> modules. You&#8217;ll find even more
functionality in specialized packages like <a class="reference external" href="http://toolz.readthedocs.org/en/latest/index.html">PyToolz</a>.</p>
</div>
<div class="section" id="how-to-create-user-defined-connection-rules">
<h2>How to create user-defined connection rules<a class="headerlink" href="#how-to-create-user-defined-connection-rules" title="Permalink to this headline">¶</a></h2>
<p>The method <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.connect" title="mosaik.scenario.World.connect"><code class="xref py py-meth docutils literal"><span class="pre">World.connect()</span></code></a> allows you to only connect one pair of
entities with each other. When you work with larger entity sets, you might not
want to connect every entity manually, but use functions that take to sets of
entities and connect them with each other based on some criteria.</p>
<p>The most common case is that you want to randomly connect the entities of one
set to another, for example, when you distribute a number of PV modules over a
power grid.</p>
<p>For this use case, mosaik provides <a class="reference internal" href="api_reference/mosaik.util.html#mosaik.util.connect_randomly" title="mosaik.util.connect_randomly"><code class="xref py py-func docutils literal"><span class="pre">mosaik.util.connect_randomly()</span></code></a>. It
takes two sets and connects them either evenly or purely randomly:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span> <span class="o">=</span> <span class="n">mosaik</span><span class="o">.</span><span class="n">World</span><span class="p">(</span><span class="n">sim_config</span><span class="p">)</span>

<span class="n">grid</span> <span class="o">=</span> <span class="n">pypower</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">gridfile</span><span class="o">=</span><span class="n">GRID_FILE</span><span class="p">)</span><span class="o">.</span><span class="n">children</span>
<span class="n">pq_buses</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">grid</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;PQBus&#39;</span><span class="p">]</span>
<span class="n">pvs</span> <span class="o">=</span> <span class="n">pvsim</span><span class="o">.</span><span class="n">PV</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>

<span class="c1"># Assuming that len(pvs) &lt; len(pq_buses), this will</span>
<span class="c1"># connect 0 or 1 PV module to each bus:</span>
<span class="n">mosaik</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">connect_randomly</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">pvs</span><span class="p">,</span> <span class="n">pq_buses</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">)</span>

<span class="c1"># This will distribute the PV modules purely randomly, but every</span>
<span class="c1"># bus will have at most 3 modules connected to it.</span>
<span class="n">mosaik</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">connect_randomly</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">pvs</span><span class="p">,</span> <span class="n">pq_buses</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span>
                              <span class="n">evenly</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">max_connects</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Another relatively common use case is connecting a set of entities to one other
entities, e.g., when you want to connect a number of controllable energy
producers to a central scheduler:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="k">def</span> <span class="nf">connect_many_to_one</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">src_set</span><span class="p">,</span> <span class="n">dest_entity</span><span class="p">,</span> <span class="o">*</span><span class="n">attrs</span><span class="p">,</span>
                        <span class="n">async_requests</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">src_entity</span> <span class="ow">in</span> <span class="n">src_set</span><span class="p">:</span>
        <span class="n">world</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">src_entity</span><span class="p">,</span> <span class="n">dest_entity</span><span class="p">,</span> <span class="o">*</span><span class="n">attrs</span><span class="p">,</span>
                      <span class="n">async_requests</span><span class="o">=</span><span class="n">async_requests</span><span class="p">)</span>


<span class="n">pvs</span> <span class="o">=</span> <span class="n">pvsim</span><span class="o">.</span><span class="n">PV</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
<span class="n">chps</span> <span class="o">=</span> <span class="n">chpsim</span><span class="o">.</span><span class="n">CHP</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="n">controller</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">Scheduler</span><span class="p">()</span>

<span class="c1"># Connect all producers to the controller, remember to set the</span>
<span class="c1"># &quot;async_requests&quot; flag.</span>
<span class="n">connect_many_to_one</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">chain</span><span class="p">(</span><span class="n">pvs</span><span class="p">,</span> <span class="n">chps</span><span class="p">),</span> <span class="n">controller</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span>
                    <span class="n">async_requests</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Connection rules are oftentimes highly specific for a project.
<a class="reference internal" href="api_reference/mosaik.util.html#mosaik.util.connect_randomly" title="mosaik.util.connect_randomly"><code class="xref py py-func docutils literal"><span class="pre">connect_randomly()</span></code></a> is currently the only function that is
useful and complicated enough to ship it with mosaik. But as you can see in the
<code class="docutils literal"><span class="pre">connect_many_to_one</span></code> example, writing your own connection method is not that
hard.</p>
</div>
<div class="section" id="how-to-retrieve-static-data-from-entities">
<h2>How to retrieve static data from entities<a class="headerlink" href="#how-to-retrieve-static-data-from-entities" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, the entities don&#8217;t contain all the information that you need in
order to decide which entity connect to which, but your simulation model could
provide that data. An example for this might be the maximum amount of active
power that a producer is able to produce.</p>
<p>Mosaik allows you to query a simulator for that data during composition time
via <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.get_data" title="mosaik.scenario.World.get_data"><code class="xref py py-meth docutils literal"><span class="pre">World.get_data()</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">exsim</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s1">&#39;ExampleSim&#39;</span><span class="p">)</span>
<span class="go">Starting &quot;ExampleSim&quot; as &quot;ExampleSim-2&quot; ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entities</span> <span class="o">=</span> <span class="n">exsim</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">init_val</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">entities</span><span class="p">,</span> <span class="s1">&#39;val_out&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="n">entities</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="go">{&#39;val_out&#39;: 42}</span>
</pre></div>
</div>
<p>The entities that you pass to this function don&#8217;t need to belong to the same
simulator (instance) as long as they all can provide the required attributes.</p>
</div>
<div class="section" id="how-to-access-topology-and-data-flow-information">
<h2>How to access topology and data-flow information<a class="headerlink" href="#how-to-access-topology-and-data-flow-information" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World" title="mosaik.scenario.World"><code class="xref py py-class docutils literal"><span class="pre">World</span></code></a> contains to <a class="reference external" href="http://networkx.github.io/documentation/latest/overview.html">networkx Graphs</a> which hold
information about the data-flows between simulators and the simulation topology
that you created in your scenario. You can use these graphs, for example, to
export the simulation topology that mosaik created into a custom data or file
format.</p>
<p><a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.df_graph" title="mosaik.scenario.World.df_graph"><code class="xref py py-attr docutils literal"><span class="pre">World.df_graph</span></code></a> is the directed <em>dataflow graph</em> for your scenarios. It
contains a note for every simulator that you started. The simulator ID is used
to label the nodes. If you established a data-flow between two simulators (by
connecting at least two of their entities), a directed edge between two nodes
is inserted.  The edges contain the <em>async_requests</em> flag (see
<a class="reference internal" href="#integrate-control-strategies"><span class="std std-ref">How to achieve bi-directional data-flows</span></a>) and a list of the data-flows.</p>
<p>The data-flow graph may, for example, look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">df_graph</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s1">&#39;PvSim-0&#39;</span><span class="p">:</span> <span class="p">{},</span>
    <span class="s1">&#39;PyPower-0&#39;</span><span class="p">:</span> <span class="p">{},</span>
<span class="p">}</span>
<span class="n">world</span><span class="o">.</span><span class="n">df_graph</span><span class="o">.</span><span class="n">edge</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s1">&#39;PvSim-0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;PypPower-0&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;async_requests&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="s1">&#39;dataflows&#39;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;PV_0&#39;</span><span class="p">,</span> <span class="s1">&#39;bus_0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;P_out&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Q_out&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;PV_1&#39;</span><span class="p">,</span> <span class="s1">&#39;bus_1&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;P_out&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Q_out&#39;</span><span class="p">,</span> <span class="s1">&#39;Q&#39;</span><span class="p">)),</span>
         <span class="p">],</span>
    <span class="p">}},</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.entity_graph" title="mosaik.scenario.World.entity_graph"><code class="xref py py-attr docutils literal"><span class="pre">World.entity_graph</span></code></a> is the undirected <em>entity graph</em>. It contains a node
for every entity. The full entity ID (<code class="docutils literal"><span class="pre">'sim_id.entity_id'</span></code>) is used as node
label.  Every node also stores the simulator name and entity type. An edge
between two entities is inserted</p>
<ul class="simple">
<li>if they are somehow related within a simulator (e.g., a PyPower branch is
related to the two PyPower buses to which it is adjacent) (see
<a class="reference internal" href="mosaik-api/low-level.html#api-create"><span class="std std-ref">create</span></a>); or</li>
<li>if they are connected via <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.connect" title="mosaik.scenario.World.connect"><code class="xref py py-meth docutils literal"><span class="pre">World.connect()</span></code></a>.</li>
</ul>
<p>The entity graph may, for example, look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">entity_graph</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s1">&#39;PvSim_0.PV_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;sim&#39;</span><span class="p">:</span> <span class="s1">&#39;PvSim&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;PV&#39;</span><span class="p">},</span>
    <span class="s1">&#39;PvSim_0.PV_1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;sim&#39;</span><span class="p">:</span> <span class="s1">&#39;PvSim&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;PV&#39;</span><span class="p">},</span>
    <span class="s1">&#39;PyPower_0.branch_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;sim&#39;</span><span class="p">:</span> <span class="s1">&#39;PyPower&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Branch&#39;</span><span class="p">},</span>
    <span class="s1">&#39;PyPower_0.bus_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;sim&#39;</span><span class="p">:</span> <span class="s1">&#39;PyPower&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;PQBus&#39;</span><span class="p">},</span>
    <span class="s1">&#39;PyPower_0.bus_1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;sim&#39;</span><span class="p">:</span> <span class="s1">&#39;PyPower&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;PQBus&#39;</span><span class="p">},</span>
<span class="p">}</span>
<span class="n">world</span><span class="o">.</span><span class="n">entity_graph</span><span class="o">.</span><span class="n">edge</span> <span class="o">==</span> <span class="p">{</span>
    <span class="s1">&#39;PvSim_0.PV_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;PyPower_0.bus_0&#39;</span><span class="p">:</span> <span class="p">{}},</span>
    <span class="s1">&#39;PvSim_0.PV_1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;PyPower_0.bus_1&#39;</span><span class="p">:</span> <span class="p">{}},</span>
    <span class="s1">&#39;PyPower_0.branch_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;PyPower_0.bus_0&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;PyPower_0.bus_1&#39;</span><span class="p">:</span> <span class="p">{}},</span>
    <span class="s1">&#39;PyPower_0.bus_0&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;PvSim_0.PV_0&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;PyPower_0.branch_0&#39;</span><span class="p">:</span> <span class="p">{}},</span>
    <span class="s1">&#39;PyPower_0.bus_1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;PvSim_0.PV_1&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;PyPower_0.branch_0&#39;</span><span class="p">:</span> <span class="p">{}},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="mosaik-api/low-level.html#rpc-get-related-entities"><span class="std std-ref">get_related_entities</span></a> API call also uses and returns (parts of)
the entity graph. So you can access it in your scenario definition as well as
from with a simulator, control strategy or monitoring tool.</p>
<p>Please consult the <a class="reference external" href="http://networkx.github.io/documentation/latest/">networkx documentation</a> for more details about
working with graphs and directed graphs.</p>
</div>
<div class="section" id="how-to-destroy-a-world">
<h2>How to destroy a world<a class="headerlink" href="#how-to-destroy-a-world" title="Permalink to this headline">¶</a></h2>
<p>When you are done working with a world, you should shut it down properly:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
</pre></div>
</div>
<p>This will, for instance, close mosaik&#8217;s socket and allows new <code class="docutils literal"><span class="pre">World</span></code>
instances to reuse the same port again.</p>
<p><a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.run" title="mosaik.scenario.World.run"><code class="xref py py-meth docutils literal"><span class="pre">World.run()</span></code></a> automatically calls <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.shutdown" title="mosaik.scenario.World.shutdown"><code class="xref py py-meth docutils literal"><span class="pre">World.shutdown()</span></code></a> for you.</p>
</div>
<div class="section" id="how-to-do-real-time-simulations">
<h2>How to do real-time simulations<a class="headerlink" href="#how-to-do-real-time-simulations" title="Permalink to this headline">¶</a></h2>
<p>It is very easy to do real-time (or &#8220;wall-clock time&#8221;) simulations in mosaik.
You just pass an <em>rt_factor</em> to <a class="reference internal" href="api_reference/mosaik.scenario.html#mosaik.scenario.World.run" title="mosaik.scenario.World.run"><code class="xref py py-meth docutils literal"><span class="pre">World.run()</span></code></a> to enable it:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">rt_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>A real-time factor of 1 means, that 1 simulation time unit (usually
a simulation second) takes 1 second of real time. Thus, if you set the
real-time factor to 0.5, the simulation will run twice as fast as the real
time. If you set it to 1/60, one simulated minute will take one real-time
second.</p>
<p>It may happen that the simulators are too slow for the real-time factor chosen.
That means, they take longer than, e.g., one second to compute a step when
a real-time factor of one second is set. If this happens, mosaik will by
default just print a warning message to stdout. However, you can also let your
simulation crash in this case by setting the parameter <em>rt_strict</em> to <code class="docutils literal"><span class="pre">True</span></code>.
Mosaik will then raise a <a class="reference external" href="http://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.7)"><code class="xref py py-exc docutils literal"><span class="pre">RuntimeError</span></code></a> if your simulation is too slow:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">world</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">until</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">rt_factor</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">60</span><span class="p">,</span> <span class="n">rt_strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="how-to-call-extra-methods-of-a-simulator">
<h2>How to call extra methods of a simulator<a class="headerlink" href="#how-to-call-extra-methods-of-a-simulator" title="Permalink to this headline">¶</a></h2>
<p>A simulator may optionally define additional API methods (see <a class="reference internal" href="mosaik-api/low-level.html#api-init"><span class="std std-ref">init</span></a>)
that you can call from your scenario. These methods can implement operations,
like setting some static data to a simulator, which don&#8217;t really fit into
<code class="docutils literal"><span class="pre">init()</span></code> or <code class="docutils literal"><span class="pre">create()</span></code>.</p>
<p>These methods are exposed via the model factory that you get when you start
a simulator. In the following example, we&#8217;ll call the <code class="docutils literal"><span class="pre">example_method()</span></code>
that the example simulator shipped with the mosaik Python API:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">world</span> <span class="o">=</span> <span class="n">mosaik</span><span class="o">.</span><span class="n">World</span><span class="p">({</span><span class="s1">&#39;ExampleSim&#39;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;python&#39;</span><span class="p">:</span> <span class="s1">&#39;example_sim.mosaik:ExampleSim&#39;</span><span class="p">}})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">es</span> <span class="o">=</span> <span class="n">world</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="s1">&#39;ExampleSim&#39;</span><span class="p">)</span>
<span class="go">Starting &quot;ExampleSim&quot; as &quot;ExampleSim-0&quot; ...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Now brace yourself ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">es</span><span class="o">.</span><span class="n">example_method</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>
<span class="go">23</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">world</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="simmanager.html" class="btn btn-neutral float-right" title="The simulator manager" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="mosaik-api/high-level.html" class="btn btn-neutral" title="The high-level API" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012-2018 OFFIS.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.5.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   
  <!-- Piwik Image Tracker-->
  <img src="https://mosaik.offis.de/analytics/piwik.php?idsite=4&rec=1" style="border:0" alt="" />
  <!-- End Piwik -->
</body>
</html>