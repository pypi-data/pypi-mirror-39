"""Base class for Avro Preprocessor modules"""

from abc import abstractmethod, ABC
from collections import OrderedDict
from typing import Callable, Union, Generator, Tuple

from avro_preprocessor.avro_domain import Avro
from avro_preprocessor.colored_json import ColoredJson
from avro_preprocessor.schemas_container import SchemasContainer

__author__ = "Nicola Bova"
__copyright__ = "Copyright 2018, Jaumo GmbH"
__email__ = "nicola.bova@jaumo.com"


class PreprocessorModule(ABC):
    """Base class for Avro Preprocessor modules"""
    def __init__(self, schemas: SchemasContainer) -> None:
        self.schemas: SchemasContainer = schemas
        self.current_schema_name = ""

    @abstractmethod
    def process(self) -> None:
        """Entry method to process data with a module."""
        pass

    def processed_schemas_and_keys_iter(self) -> Generator[Tuple[str, OrderedDict], None, None]:
        """
        A generator to iterate over processed schemas and autogenerated keys.
        I also sets the current schema name so it can be retrieved by AvroPreprocessor
        in case an exception happens.
        """
        all_schemas = list(self.schemas.processed.items()) \
                      + list(self.schemas.autogenerated_keys.items())

        for schema_name, schema in all_schemas:
            self.current_schema_name = schema_name
            yield schema_name, schema

    def processed_schemas_iter(self) -> Generator[Tuple[str, OrderedDict], None, None]:
        """
        A generator to iterate over processed schemas.
        I also sets the current schema name so it can be retrieved by AvroPreprocessor
        in case an exception happens.
        """
        for schema_name, schema in self.schemas.processed.items():
            self.current_schema_name = schema_name
            yield schema_name, schema

    def original_schemas_iter(self) -> Generator[Tuple[str, OrderedDict], None, None]:
        """
        A generator to iterate over original schemas.
        I also sets the current schema name so it can be retrieved by AvroPreprocessor
        in case an exception happens.
        """
        for schema_name, schema in self.schemas.original.items():
            self.current_schema_name = schema_name
            yield schema_name, schema

    def traverse_schema(self,
                        schema: Union[str, list, OrderedDict],
                        func: Callable[[OrderedDict], None]) -> None:
        """
        Recursively traverse a schema and apply 'func' to chosen elements.
        :param schema: The schema to traverse
        :param func: The function to apply
        """
        if isinstance(schema, str):
            return

        if isinstance(schema, list):
            for item in schema:
                self.traverse_schema(item, func)

        elif isinstance(schema, OrderedDict):
            func(schema)

            if Avro.Fields in schema:
                for field in schema[Avro.Fields]:

                    if not isinstance(field[Avro.Type], str):
                        # complex types such as record or list
                        self.traverse_schema(field[Avro.Type], func)

                    func(field)

            if Avro.Items in schema:
                func(schema)

        else:
            raise ValueError(
                "Unexpected type {}: {}".format(
                    type(schema), ColoredJson.highlight_json(schema, indent=None)))
