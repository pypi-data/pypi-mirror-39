import logging
import importlib
import time
from math import exp

try:
    from KMCLib import *
except ImportError:
    print("!!! Any kMC calculation using KMCLib will be disabled !!!")

from ..descriptors.descriptors import Property
from .. import __version__
from ..errors.error import *
from ..database.thermo_data import kB_eV
from ..database.lattice_data import *
from .solver_base import SolverBase
from ..utilities.profiling_utitlities import do_cprofile
from ..utilities.check_utilities import check_process_dict


class KMCSolver(SolverBase):
    def __init__(self, owner):
        """
        Class for kinetic Monte Carlo simulation.
        """
        super(KMCSolver, self).__init__(owner)

        # set logger
        self.__logger = logging.getLogger('model.solvers.KMCSolver')

        # scripting header
        self.__script_header = (
            '# This file was automatically generated by scaks' +
            ' (https://github.com/PytLab/scaks) powered by KMCLibX.\n' +
            '# Version {}\n# Date: {} \n#\n' +
            '# Do not make changes to this file ' +
            'unless you know what you are doing\n\n').format(__version__, time.asctime())

        # Set process reaction mapping.
        self.__process_mapping = []

    def run(self,
            scripting=True,
            trajectory_type="lattice"):
        """
        Run the KMC lattice model simulation with specified parameters.

        Parameters:
        -----------
        scripting: generate lattice script or not, True by default, bool.

        trajectory_type: The type of trajectory to use, the default type is "lattice", str.
                         "xyz" | "lattice".

        """
        # {{{
        # Get analysis.
        analysis_name = self._owner.analysis
        if analysis_name:
            analysis = []
            for classname in analysis_name:
                _module = importlib.import_module('scaks.solvers.kmc_plugins')
                analysis_object = getattr(_module, classname)(self._owner)
                analysis.append(analysis_object)
        else:
            analysis = None

        # Get interactions.
        interactions = KMCInteractions(processes=self.processes,
                                       implicit_wildcards=True)

        # Get configuration.
        configuration = self._owner.configuration

        # Get sitesmap.
        sitesmap = self._owner.sitesmap

        # Construct KMCLatticeModel object.
        model = KMCLatticeModel(configuration=configuration,
                                sitesmap=sitesmap,
                                interactions=interactions)

        if scripting:
            if self._owner.log_allowed:
                self.script_lattice_model(model, script_name='kmc_model.py')
                self.__logger.info('script auto_kmc_model.py created.')

        # Get KMCControlParameters.
        control_parameters = self.get_control_parameters()

        # Get trajectory file name.
        trajectory_filename = "auto_{}_trajectory.py".format(trajectory_type)

        # Run KMC main loop.
        if self._owner.log_allowed:
            self.__logger.info("")
            self.__logger.info("Entering KMCLibX main kMC loop...")

        model.run(control_parameters=control_parameters,
                  trajectory_filename=trajectory_filename,
                  trajectory_type=trajectory_type,
                  analysis=analysis)
        # }}}

    def get_processes(self):
        all_processes = []
        process_dicts = self._owner.process_dicts
        for process_dict in process_dicts:
            processes = self.__get_single_process(process_dict)
            all_processes.extend(processes)

        return all_processes

    def __get_single_process(self, process_dict):
        """
        Private helper function to convert a process dict to KMCLibProcess object.
        """
        # {{{
        # Check process dict.
        process_dict = check_process_dict(process_dict)

        # Check if reaction in rxn_expressions.
        rxn_expressions = self._owner.rxn_expressions

        if process_dict["reaction"] not in rxn_expressions:
            msg = "'{}' is not in model's rxn_expressions.".format(process_dict["reaction"])
            raise SetupError(msg)

        # Check if the elements are in possible elements.
        all_elements = process_dict["elements_before"] + process_dict["elements_after"]
        possible_elements = self._owner.possible_element_types
        for element in all_elements:
            if element not in possible_elements:
                msg = "Element '{}' in process not in possible types {}"
                msg = msg.format(element, possible_elements)
                raise SetupError(msg)

        # Get rate constants.
        if self._owner.rate_algo == "CT":
            rf, rr = self.get_rxn_rates_CT(process_dict["reaction"],
                                           self._owner.relative_energies,
                                           include_pressure=True)
        elif self._owner.rate_algo == "TST":
            rf, rr = self.get_rxn_rates_TST(process_dict["reaction"],
                                            self._owner.relative_energies,
                                            include_pressure=True)

        # Get process fast flag, False by default.
        fast = process_dict.get("fast", False)

        # Get process redist flag, Falst by default.
        redist = process_dict.get("redist", False)

        # Get process redist species.
        redist_species = process_dict.get("redist_species", None)

        # Get KMCLibProcess objects.
        processes = []

        for basis_site in process_dict["basis_sites"]:
            for coordinates in process_dict["coordinates_group"]:
                if self._owner.log_allowed:
                    self.__logger.info("Coordinates = {}".format(coordinates))
                    self.__logger.info("Basis site = {}".format(basis_site))

                # Forward process.
                fprocess = KMCProcess(coordinates=coordinates,
                                      elements_before=process_dict["elements_before"],
                                      elements_after=process_dict["elements_after"],
                                      basis_sites=[basis_site],
                                      rate_constant=rf,
                                      fast=fast,
                                      redist=redist,
                                      redist_species=redist_species)
                processes.append(fprocess)

                # Add process reaction mapping.
                if not fast:
                    process_mapping = "{}(->)".format(process_dict["reaction"])
                    self.__process_mapping.append(process_mapping)

                # Info output.
                if self._owner.log_allowed:
                    self.__logger.info("Forward elements changes:")
                    self.__logger.info("    /{}".format(process_dict["elements_before"]))
                    self.__logger.info("    \{}".format(process_dict["elements_after"]))

                # --------------------------------------------------------------
                # NOTE: If the proess is a redistribution process which is only
                #       used to re-scatter the fast species, its reverse process
                #       would not be parsed.
                # --------------------------------------------------------------

                # Reverse process.
                if not redist:
                    rprocess = KMCProcess(coordinates=coordinates,
                                          elements_before=process_dict["elements_after"],
                                          elements_after=process_dict["elements_before"],
                                          basis_sites=[basis_site],
                                          rate_constant=rr,
                                          fast=fast)
                    processes.append(rprocess)

                # Add process reaction mapping.
                if not fast:
                    process_mapping = "{}(<-)".format(process_dict["reaction"])
                    self.__process_mapping.append(process_mapping)

                # Info output.
                if not redist and self._owner.log_allowed:
                    self.__logger.info("Reverse elements changes:")
                    self.__logger.info("    /{}".format(process_dict["elements_after"]))
                    self.__logger.info("    \{}".format(process_dict["elements_before"]))

        if self._owner.log_allowed:
            self.__logger.info("\n")

        return processes
        # }}}

    def get_control_parameters(self):
        """
        Function to get KMCLib KMCControlParameters instance.
        """
        # {{{
        # Get parameters in model.
        time_limit=self._owner.time_limit
        number_of_steps=self._owner.nstep
        dump_interval=self._owner.trajectory_dump_interval
        seed=self._owner.random_seed
        rng_type=self._owner.random_generator
        analysis_interval=self._owner.analysis_interval
        start_time=self._owner.start_time
        extra_traj=self._owner.extra_trajectories
        do_redistribution=self._owner.do_redistribution

        control_params = dict(time_limit=time_limit,
                              number_of_steps=number_of_steps,
                              dump_interval=dump_interval,
                              seed=seed,
                              rng_type=rng_type,
                              analysis_interval=analysis_interval,
                              start_time=start_time,
                              extra_traj=extra_traj,
                              do_redistribution=do_redistribution)

        if do_redistribution:
            redistribution_dict = dict(
                redistribution_interval=self._owner.redistribution_interval,
                fast_species=self._owner.fast_species,
                nsplits=self._owner.nsplits,
                distributor_type=self._owner.distributor_type,
                empty_element=self._owner.empty_type
            )
            control_params.update(redistribution_dict)

        # KMCLib control parameter instantiation
        control_parameters = KMCControlParameters(**control_params)

        return control_parameters
        # }}}

    #-----------------------
    # script KMCLib objects |
    #-----------------------

    def script_decorator(func):
        '''
        Decorator for KMCLib objects scripting.
        Add some essential import statements and save operation.
        '''
        def wrapper(self, obj, script_name=None):
            content = self.__script_header + 'from KMCLib import *\n\n'
            content += func(self, obj)

            # write to file
            if script_name:
                script_name = 'auto_' + script_name
                with open(script_name, 'w') as f:
                    f.write(content)
                if self._owner.log_allowed:
                    self.__logger.info('interactions script written to %s', script_name)

            return content

        return wrapper

    @script_decorator
    def script_lattice_model(self, lattice_model):
        """
        Generate a script representation of lattice model instances.

        Parameters:
        -----------
        lattice_model: The KMCLatticeModel object.

        script_name: filename into which script written, str.
                     set to None by default and no file will be generated.

        Returns:
        --------
        A script that can generate this lattice model object, str.

        """
        content = lattice_model._script()

        return content

    @script_decorator
    def script_configuration(self, configuration):
        '''
        Generate a script representation of interactions instances.

        Parameters:
        -----------
        configuration: The KMCConfiguration object.

        script_name: filename into which script written, str.
                     set to None by default and no file will be generated.

        Returns:
        --------
        A script that can generate this configuration object, str.

        '''
        content = configuration._script()

        return content

    @script_decorator
    def script_interactions(self, interactions):
        '''
        Generate a script representation of interactions instances.

        Parameters:
        -----------
        interactions: The KMCInteractions object.

        script_name: filename into which script written, str.
                     set to None by default and no file will be generated.

        Returns:
        --------
        A script that can generate this interactions object, str.

        '''
        content = interactions._script()

        return content

    @script_decorator
    def script_processes(self, processes):
        '''
        Generate a script representation of processes instances.

        Parameters:
        -----------
        processes: A list of KMCProcess object.

        script_name: filename into which script written, str.
                     set to None by default and no file will be generated.

        Returns:
        --------
        A script that can generate this process object, str.

        '''
        # Get content string.
        content = ''
        for idx, proc in enumerate(processes):
            proc_str = proc._script('process_%d' % idx)
            content += proc_str
        # gather processes
        proc_str = 'processes = [\n'
        for idx in range(len(processes)):
            proc_str += (' '*4 + 'process_%d,\n' % idx)
        proc_str += ']\n\n'

        content += proc_str

        return content

    @Property
    def processes(self):
        """
        Query function for processes list.
        """
        try:
            return self.__processes
        except AttributeError:
            self.__processes = self.get_processes()
            return self.__processes

    @Property
    def process_mapping(self):
        """
        Query function for process reaction type mapping.
        """
        return self.__process_mapping

