"""
Contains classes and functions that define the database API
"""
import getpass
from os import access, listdir, path, R_OK, W_OK
import pathlib
import smtplib
import sqlite3
from types import TracebackType

import feedparser as fp

from podd.config import Config
from podd.utilities import logger


class Database:
    """
    Defines database operations - Adding, removing, getting podcasts and episodes
    from the database, etc
    """

    def __init__(self, db_file: str = Config.database):
        self._db_file = db_file
        self._conn = sqlite3.connect(self._db_file)
        self._conn.execute('PRAGMA foreign_keys=ON')
        self.cursor = self._conn.cursor()
        self._logger = logger(f'{self.__class__.__name__}')

    def __enter__(self):
        return self

    def __exit__(self,
                 exc_type,
                 exc_val,
                 exc_tb: TracebackType):
        """
        If there are exceptions, rolls back and calls logger
        :param exc_type: exception type
        :param exc_val:  exception value
        :param exc_tb: exception traceback
        :return: None
        """
        if exc_type is not None:
            self._conn.rollback()
            self._logger.error(exc_type, exc_val, exc_tb)

        else:
            self._conn.commit()
        self._conn.close()

    def __repr__(self):
        return f'{self.__class__.__name__}({self._db_file})'

    def add_podcast(self, name: str, url: str, directory: str) -> None:
        """
        :param name: podcast name
        :param url: rss feed url
        :param directory: directory to store this podcast's downloaded episodes
        :return: None
        """
        self._logger.info(f'Adding {name} {url} at {directory}')
        self.cursor.executemany('INSERT INTO podcasts (name, url, directory) VALUES (?,?,?)',
                                ((name, url, directory),))
        self._conn.commit()

    def remove_podcast(self, url: str) -> None:
        """
        Deletes all episodes associated with rss feed URL, as well as podcast entry
        :param url: rss feed url
        :return: None
        """
        self.cursor.execute('DELETE FROM episodes WHERE podcast_id IN'
                            ' (SELECT id FROM podcasts p WHERE p.url = ?)', (url,))
        self.cursor.execute('DELETE FROM  podcasts WHERE url = ?',
                            (url,))
        self._conn.commit()

    def get_podcasts(self) -> list:
        """
        :return: list of tuples of podcast name, url and download directory
        """
        self.cursor.execute('SELECT name, url, directory FROM main.podcasts')
        return self.cursor.fetchall()

    def add_episode(self,
                    podcast_url: str,
                    feed_id: str, ) -> None:
        """
        :param podcast_url: RSS feed URL
        :param feed_id: id generated by rss feed for each episode
        :return: None
        """
        self.cursor.execute('INSERT INTO episodes (feed_id, podcast_id) '
                            'SELECT ?, id FROM main.podcasts WHERE url = ?',
                            (feed_id, podcast_url))
        self._conn.commit()

    def get_episodes(self, url: str) -> set:
        """
        :param url: rss feed url
        :return: dict of episode ids associated with url
        """
        self.cursor.execute('SELECT feed_id FROM episodes '
                            'JOIN podcasts p ON episodes.podcast_id = p.id AND p.url = ?',
                            (url,))
        return {item[0] for item in self.cursor.fetchall()}

    def get_options(self) -> tuple:
        """
        :return: tuple of currently set options
        """
        self.cursor.execute('SELECT new_only, '
                            'download_directory, '
                            'notification_status, '
                            'recipient_address FROM settings')
        return self.cursor.fetchone()

    def get_credentials(self) -> tuple:
        """
        :return: tuple of sender_address, sender_password, and recipient_address
        """
        self.cursor.execute('SELECT sender_address, '
                            'sender_password, '
                            'recipient_address from settings where id = 1')
        return self.cursor.fetchone()

    def change_option(self, option: str, value: str or int) -> None:
        """
        I know, I know, using a database query with an fstring is problematic,
        Ã  la bobby tables, but the user doesn't interact directly with the
        database with this or any other queries that use fstrings in queries.
        All values input by the user are parameterized, which mitigates the threat.
        Given what this application is and does, I'm not sure why any user would
        try to sql injection on a local db of which they have sole access.
        :param option: string, option to change
        :param value: string, option's new value
        :return: None
        """
        self.cursor.execute(f'UPDATE settings SET {option} = ? WHERE id = 1', (value,))
        self._conn.commit()
        if option == 'sender_password':
            value = 'REDACTED'
        self._logger.info(f'Changed {option} to {value}')


class Feed(Database):
    """
    Contains methods for managing rss feeds, including adding and removing podcasts
    to database, viewing current subscription feeds, etc
    """

    def add(self, *urls) -> None:
        """
        Parses and validates rss feed urls, adds to database, creates
        download directory for each new feed added
        :param urls: rss feed urls
        :return: None
        """
        try:
            for url in urls:
                newest_only, dl_dir, *_ = self.get_options()
                feed = fp.parse(url)
                self._logger.info(f'Parsing {url}')
                episodes = feed.entries
                if not episodes:
                    msg = f'No episodes at {url}'
                    print(msg)
                    self._logger.warning(msg)
                    raise KeyError
                podcast_name = feed.feed.title
                podcast_dir = path.join(dl_dir, podcast_name)
                self.add_podcast(name=podcast_name, url=feed.href, directory=podcast_dir)
                # url=feed.href covers cases when rss feeds redirect to a diff URL.
                # That was a fun one to debug.
                if newest_only:
                    self._new_podcast_only(feed=feed)
                pathlib.Path(podcast_dir).mkdir(parents=True, exist_ok=True)
                msg = f'{podcast_name} added!'
                print(msg)
                self._logger.info(msg)
        except sqlite3.IntegrityError:
            msg = f'{podcast_name} already in database.'
            self._logger.warning(msg)
            print(msg)
        except KeyError:
            self._logger.exception('Error, podcast not added')

    def remove(self) -> None:
        """
        Used with simple CLI interface, used to remove a podcast from database
        :return: None
        """
        podcasts = {i[0]: i[1] for i in enumerate(self.get_podcasts())}
        if not podcasts:
            print('You have no subscriptions!')
            return
        for num, podcast in podcasts.items():
            print(f'{num}: {podcast[0]}')
        try:
            choice = int(input('Podcast number to remove: '))
            if choice not in podcasts:
                print('Invalid option')
                return
            self.remove_podcast(podcasts[choice][1])
            msg = f'Removed {podcasts[choice][0]}'
            print(msg)
            self._logger.info(msg)
        except ValueError:
            print('Invalid option, enter a number')
        except KeyboardInterrupt:
            print('\nCanceled')

    def _new_podcast_only(self, feed: fp.FeedParserDict) -> None:
        """
        Loops through episodes, adding all episodes, excepting the newest, to the database,
        Used when adding a new podcast to the database.
        :param feed: FeedParserDict of a single feed
        :return: None
        """
        episodes = feed.entries
        first = episodes[0].published_parsed
        last = episodes[-1].published_parsed
        if first < last:  # Last is the latest episode, i.e., feed is reversed
            episodes = episodes[:-1]
        else:
            episodes = episodes[1:]
        for epi in episodes:
            self.add_episode(podcast_url=feed.href, feed_id=epi.id)

    def print_subscriptions(self) -> None:
        """
        Prints current subscriptions
        :return: None
        """
        print('----------Current subscriptions----------')
        for sub in self.get_podcasts():
            print(sub[0])
        print('-----------------------------------------')


class Options(Database):
    """
    Contains methods to manage and view options stored in the database.
    """

    def toggle_notifications(self, value) -> None:
        """
        Turns email notifications on or off, depending upon supplied value
        :param value:
        :return:
        """
        valid = {'on': True, 'off': False}
        if value not in valid:
            print('Invalid option')
            return
        sender, *_ = self.get_credentials()
        if sender == '' and value == 'on':
            print('You need to enter a valid email address.  Run `python3 podd.py -e` first.')
            return
        self.change_option('notification_status', valid[value])
        msg = f'Notifications turned {value}.'
        print(msg)
        self._logger.info(msg)

    def email_notification_setup(self, initial_setup: bool = False) -> None:
        """
       Interacts with user, gets sender email address and password, as well as recipient address
       :param initial_setup: bool if True, prints additional info
       :return: namedtuple of sender address and password and recipient address
       """

        def credential_validation() -> bool:
            """
            creates a simple smtp server and attempts to log in to server using the
            provided credentials
            :return: bool, True if login attempt was successful, False otherwise
            """
            server = smtplib.SMTP(host=Config.host, port=Config.port)
            server.starttls()
            try:
                status_code = server.login(user=sender_address, password=password)[0]
                server.quit()
                if status_code == 235:
                    return True
            except smtplib.SMTPAuthenticationError:
                pass
            return False

        if initial_setup:
            print('Looks like this is your first time running the program.')
            choice = input('Would you like to enable email notifications? (y/n) ').lower()
            if choice != 'y':
                msg = 'Email notifications disabled.'
                print(msg)
                self._logger.info(msg)
                return
        print('\nNote: if you are using a Gmail account for this purpose, you need \n'
              'to enable app-specific passwords and enter one you\'ve generated, \n'
              'rather than your normal password.  This is somewhat risky, so it is\n'
              'advised that you do NOT use your main gmail account for this purpose. \n'
              'See https://support.google.com/accounts/answer/185833?hl=en for more info.\n'
              'The default values in config.py use the ones provided by gmail, \n'
              'if you choose to use a different email provider, replace them with the\n'
              'correct values.\n')
        print('First, enter in the address you want to use to send notifications')
        try:
            sender_address = input('Email address: ')
            password = getpass.getpass('Password: ')
            print('Validating password...')
            if not credential_validation():
                msg = 'Login attempt failed!  Bad username or password!'
                self._logger.warning(msg)
                print(msg)
                return
            msg = 'Email authentication successful.'
            self._logger.info(msg)
            print(msg)
            print('\nNow enter the recipient email address.')
            recipient_address = input('Email address: ')
            self.change_option('sender_address', sender_address)
            self.change_option('sender_password', password)
            self.change_option('recipient_address', recipient_address)
            self.change_option('notification_status', True)
            msg = 'Email notification enabled!'
            print(msg)
            self._logger.info(msg)
        except KeyboardInterrupt:
            print('\nCanceling')
            quit()

    def print_options(self) -> tuple:
        """
        Prints currently selected options
        :return: None
        """
        valid_options = {0: 'New podcasts download all episodes\n',
                         1: 'New podcasts download only new episodes\n'}
        email_notification_status = {0: 'Off', 1: 'On'}
        new_only, download_directory, notification_status, recipient_address = self.get_options()
        print('-- Options --')
        print(f'{valid_options[new_only]}Download Directory: {download_directory}')
        print(f'Email notifications: {email_notification_status[notification_status]}')
        if notification_status:
            print(f'Email notifications sent to: {recipient_address}')
        print(f'Database file: {self._db_file}')
        print('-------------')
        return new_only, download_directory, notification_status, recipient_address

    def set_directory_option(self, directory) -> bool:
        """
        Sets the base download directory, where each individual podcast
        download directory will be created
        :param directory: string, abs path to base download directory
        :return: None
        """
        if access(directory, W_OK) and access(directory, R_OK):
            self.change_option('download_directory', directory)
            msg = f'Changed download directory to {directory}'
            print(msg)
            self._logger.info(msg)
            return True
        msg = f'Invalid directory: {directory}'
        print(msg)
        self._logger.warning(msg)
        return False

    def set_catalog_option(self, option) -> bool:
        """
        Sets catalog download option.  When adding new podcasts, if new_only is 1,
        all episodes except newest will be added to database, preventing them from
        being downloaded.  if new_only is 0, then all episodes will be downloaded.
        :param option: string, catalog option desired
        :return: None
        """
        valid_options = {'all': '0', 'new': '1'}
        if option not in valid_options:
            msg = f'Invalid option: {option}'
            print(msg)
            self._logger.warning(msg)
            return False
        self.change_option('new_only', valid_options[option])
        msg = f'Set catalog option to {option}'
        print(msg)
        self._logger.info(msg)
        return True


def create_database(database: str = Config.database) -> bool:
    """
    Looks in the directory of the given filename, if the file is absent,
    it creates the database with default values.
    :param database: string, abs path of database file
    :return: None
    """
    files = [path.join(path.dirname(database), item) for item in
             listdir(path.dirname(database))]
    if database not in files:
        sender, password, recipient, notifications = '', '', '', False
        with Database(database) as _db:
            cur = _db.cursor
            cur.execute('CREATE TABLE IF NOT EXISTS podcasts '
                        '(id INTEGER PRIMARY KEY, '
                        'name TEXT, '
                        'url TEXT UNIQUE, '
                        'directory TEXT)')
            cur.execute('CREATE TABLE IF NOT EXISTS episodes '
                        '(id INTEGER PRIMARY KEY, '
                        'feed_id TEXT, '
                        'podcast_id INTEGER NOT NULL,'
                        'FOREIGN KEY (podcast_id) REFERENCES podcasts(id))')
            cur.execute('CREATE TABLE IF NOT EXISTS settings '
                        '(id INTEGER PRIMARY KEY, '
                        'new_only BOOLEAN, '
                        'download_directory TEXT,'
                        'notification_status BOOLEAN,'
                        'sender_address TEXT,'
                        'sender_password TEXT,'
                        'recipient_address TEXT)')
            cur.execute('INSERT INTO settings (new_only,'
                        ' download_directory,'
                        ' notification_status,'
                        ' sender_address,'
                        ' sender_password,'
                        ' recipient_address) VALUES (?,?,?,?,?,?)',
                        (1, path.join(pathlib.Path.home(), 'Podcasts'),
                         notifications, sender, password, recipient), )
        pathlib.Path(path.join(path.dirname(path.abspath(__file__)), 'Logs')).\
            mkdir(exist_ok=True)
        return True
    return False
